#!/bin/zsh
# yday-semantic - Show git activity with semantic summaries

# Default parent directory
parent_dir="$HOME/workspace"
show_all=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --all)
      show_all=true
      shift
      ;;
    --parent=*)
      parent_dir="${1#*=}"
      # Expand tilde
      parent_dir="${parent_dir/#\~/$HOME}"
      shift
      ;;
    *)
      echo "Usage: $0 [--all] [--parent=<directory>]"
      echo "  --all: Show all repos regardless of recent activity"
      echo "  --parent=<dir>: Directory to search for git repos (default: ~/workspace)"
      exit 1
      ;;
  esac
done

# Initialize arrays
declare -A seen_repos  # To track duplicates
all_entries=()
found=0

echo "## Git Repository Activity..."
echo ""

# Function to get relative time and days for sorting
get_relative_time() {
  local timestamp="$1"
  if [[ -z "$timestamp" ]]; then
    echo "never|99999"
    return
  fi
  
  # Calculate days ago for sorting
  local commit_date=$(date -j -f "%Y-%m-%d %H:%M:%S" "$timestamp" "+%s" 2>/dev/null)
  local now=$(date "+%s")
  local diff=$((now - commit_date))
  local days=$((diff / 86400))
  
  # Format display text
  local display_text
  if [[ $days -eq 0 ]]; then
    display_text="0 days ago (today)"
  elif [[ $days -eq 1 ]]; then
    display_text="1 day ago (yesterday)"
  else
    display_text="${days} days ago"
  fi
  
  # Return both display text and days for sorting (separated by |)
  echo "${display_text}|${days}"
}

# Function to generate semantic summary
generate_semantic_summary() {
  local messages="$1"
  local project="$2"
  
  # Use the semantic_summarize script if available
  if [[ -x ~/workspace/dot-rot/bin/semantic_summarize ]]; then
    summary=$(echo "$messages" | ~/workspace/dot-rot/bin/semantic_summarize "$project" 2>/dev/null)
    if [[ -n "$summary" ]]; then
      echo "$summary"
      return
    fi
  fi
  
  # Fallback: extract keywords
  keywords=$(echo "$messages" | \
    grep -o -E '\b[a-zA-Z]{4,}\b' | \
    grep -v -E '^(with|from|into|this|that|have|been|were|will|your|their|them|they|when|where|what|which|also|some|work|more)$' -i | \
    sort | uniq -c | sort -nr | head -3 | \
    awk '{print $2}' | tr '\n' ' ' | sed 's/ $//')
  
  if [[ -n "$keywords" ]]; then
    echo "$keywords"
  else
    echo "$messages" | head -1 | cut -c 1-30
  fi
}

# Function to check if a path is a git worktree
is_worktree() {
  local repo_dir="$1"
  [[ -f "$repo_dir/.git" ]]
}

# Function to process a git repository
process_repo() {
  local repo_dir="$1"
  local repo_name="$2"
  local is_wt=$(is_worktree "$repo_dir")
  
  # Get the most recent commit across all branches
  local most_recent_commit=$(git -C "$repo_dir" log --all --format="%H|%ci|%s" -1 2>/dev/null)
  
  if [[ -z "$most_recent_commit" ]]; then
    # No commits in repo
    if $show_all; then
      # Skip duplicates
      local repo_key="${repo_dir}"
      if [[ -z "${seen_repos[$repo_key]}" ]]; then
        seen_repos[$repo_key]=1
        all_entries+=("99999|$repo_name|never|never|-|0|-|$is_wt")
        ((found++))
      fi
    fi
    return
  fi
  
  # Parse the most recent commit info
  IFS='|' read -r commit_hash commit_date commit_message <<< "$most_recent_commit"
  
  # Find which branch contains this commit
  local branch_with_commit=$(git -C "$repo_dir" branch --all --contains "$commit_hash" 2>/dev/null | \
    sed 's/^[* ] //' | \
    sed 's|^remotes/origin/||' | \
    grep -v '^(' | \
    head -1)
  
  # Clean up branch name
  branch_with_commit=$(echo "$branch_with_commit" | sed 's|^remotes/[^/]*/||')
  
  # Get the date part only (YYYY-MM-DD)
  local commit_date_only=$(echo "$commit_date" | cut -d' ' -f1)
  
  # Get relative time and days for sorting
  local time_result=$(get_relative_time "$commit_date")
  IFS='|' read -r relative_time days_ago <<< "$time_result"
  
  # Skip duplicates - use repo_dir to distinguish worktrees from regular repos
  local repo_key="${repo_dir}"
  if [[ -n "${seen_repos[$repo_key]}" ]]; then
    return
  fi
  seen_repos[$repo_key]=1
  
  # Count commits on that date on that branch
  local commits_count=$(git -C "$repo_dir" log "$branch_with_commit" \
    --after="$commit_date_only 00:00:00" \
    --before="$commit_date_only 23:59:59" \
    --oneline 2>/dev/null | wc -l | tr -d ' ')
  
  # Get all commit messages from that date for summary
  local day_messages=$(git -C "$repo_dir" log "$branch_with_commit" \
    --after="$commit_date_only 00:00:00" \
    --before="$commit_date_only 23:59:59" \
    --format="%s" 2>/dev/null)
  
  # Generate summary
  local summary=""
  if [[ -n "$day_messages" ]]; then
    summary=$(generate_semantic_summary "$day_messages" "$repo_name")
  else
    summary="-"
  fi
  
  # Add entry with days_ago for sorting
  all_entries+=("$days_ago|$repo_name|$relative_time|$branch_with_commit|$commits_count|$summary|$is_wt")
  ((found++))
}

# Process all git repositories
for repo_path in $(find "$parent_dir" -name ".git" -maxdepth 3 2>/dev/null | sort); do
  if [[ -d "$repo_path" ]]; then
    # Regular git repository
    repo_dir=$(dirname "$repo_path")
  else
    # Git worktree (file)
    repo_dir=$(dirname "$repo_path")
  fi
  
  repo_name=$(basename "$repo_dir")
  
  # Skip if it's the parent directory itself
  [[ "$repo_name" == "$(basename "$parent_dir")" ]] && continue
  
  process_repo "$repo_dir" "$repo_name"
done

# Sort entries by days ago (numeric sort)
IFS=$'\n' sorted_entries=($(sort -t'|' -k1,1n <<< "${all_entries[*]}"))

# Calculate column widths for proper formatting
max_repo=4      # "Repo"
max_updated=12  # "Last Updated"
max_branch=6    # "Branch"
max_commits=7   # "Commits"
max_summary=7   # "Summary"
max_worktree=8  # "Worktree"

# Find maximum widths
for entry in "${sorted_entries[@]}"; do
  IFS='|' read -r days_ago repo updated branch commits summary worktree <<< "$entry"
  [[ ${#repo} -gt $max_repo ]] && max_repo=${#repo}
  [[ ${#updated} -gt $max_updated ]] && max_updated=${#updated}
  [[ ${#branch} -gt $max_branch ]] && max_branch=${#branch}
  [[ ${#summary} -gt $max_summary ]] && max_summary=${#summary}
done

# Cap maximum widths for readability
[[ $max_repo -gt 25 ]] && max_repo=25
[[ $max_updated -gt 20 ]] && max_updated=20  # Increased for "0 days ago (today)"
[[ $max_branch -gt 20 ]] && max_branch=20
[[ $max_summary -gt 40 ]] && max_summary=40

# Print table header
printf "| %-${max_repo}s | %-${max_updated}s | %-${max_branch}s | %-${max_commits}s | %-${max_summary}s | %-${max_worktree}s |\n" \
  "Repo" "Last Updated" "Branch" "Commits" "Summary" "Worktree"

# Print separator line
printf "|"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_repo + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_updated + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_branch + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_commits + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_summary + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_worktree + 2))))"
printf "\n"

if [[ $found -eq 0 ]]; then
  printf "| %-${max_repo}s | %-${max_updated}s | %-${max_branch}s | %-${max_commits}s | %-${max_summary}s | %-${max_worktree}s |\n" \
    "-" "-" "-" "-" "No repos found" "-"
else
  for entry in "${sorted_entries[@]}"; do
    IFS='|' read -r days_ago repo updated branch commits summary worktree <<< "$entry"
    
    # Convert boolean to yes/no
    if [[ "$worktree" == "true" ]]; then
      worktree_display="yes"
    else
      worktree_display="no"
    fi
    
    # Truncate if needed
    repo=${repo:0:$max_repo}
    updated=${updated:0:$max_updated}
    branch=${branch:0:$max_branch}
    summary=${summary:0:$max_summary}
    
    printf "| %-${max_repo}s | %-${max_updated}s | %-${max_branch}s | %-${max_commits}s | %-${max_summary}s | %-${max_worktree}s |\n" \
      "$repo" "$updated" "$branch" "$commits" "$summary" "$worktree_display"
  done
fi

# Add blank line after the table
echo ""