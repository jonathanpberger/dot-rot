#!/bin/zsh
# yday-semantic - Show git activity with semantic summaries

# Get yesterday's date
yesterday=$(date -v-1d +"%Y-%m-%d")
today=$(date +"%Y-%m-%d")

# Initialize arrays
all_entries=()
found=0

echo "## Yesterday in Git ($yesterday)..."
echo ""

# Function to generate semantic summaries
generate_semantic_summary() {
  local messages="$1"
  local project="$2"
  
  # Extract meaningful keywords from commit messages
  # Remove common words and focus on meaningful terms
  keywords=$(echo "$messages" | \
    grep -o -E '\b[a-zA-Z]{4,}\b' | \
    grep -v -E '^(with|from|into|this|that|have|been|were|will|your|their|them|they|when|where|what|which)$' | \
    sort | uniq -c | sort -nr | head -3 | \
    awk '{print $2}' | tr '\n' ', ' | sed 's/,$//')
  
  if [[ -n "$keywords" ]]; then
    echo "$keywords"
  else
    # If no keywords, use the first commit message as summary
    echo "$messages" | head -1 | cut -c 1-40
  fi
}

# Function to process a git repository
process_repo() {
  local repo_dir="$1"
  local repo_name="$2"
  
  # Get all branches with commits from yesterday
  cd "$repo_dir" 2>/dev/null || return
  
  # Get all branches (local and remote)
  branches=$(git for-each-ref --format='%(refname:short)' refs/heads/ 2>/dev/null)
  
  while IFS= read -r branch; do
    # Skip empty branch names
    [[ -z "$branch" ]] && continue
    
    # Get yesterday's commits for this branch
    commits=$(git log "$branch" --oneline --after="$yesterday 00:00" --before="$today 00:00" 2>/dev/null)
    
    if [[ -n "$commits" ]]; then
      commit_count=$(echo "$commits" | wc -l | tr -d ' ')
      commit_messages=$(echo "$commits" | sed 's/^[^ ]* //')
      summary=$(generate_semantic_summary "$commit_messages" "$repo_name")
      
      # Add entry for this branch
      all_entries+=("$repo_name|$branch|$commit_count|$summary")
      ((found++))
    fi
  done <<< "$branches"
}

# First pass - standard git repositories
for repo_path in $(find ~/workspace -type d -name ".git" -maxdepth 3 2>/dev/null | sort); do
  repo_dir=$(dirname "$repo_path")
  repo_name=$(basename "$repo_dir")
  
  # Skip if it's the workspace directory itself
  [[ "$repo_name" == "workspace" ]] && continue
  
  process_repo "$repo_dir" "$repo_name"
done

# Second pass - git worktrees (where .git is a file)
for git_file in $(find ~/workspace -type f -name ".git" -maxdepth 3 2>/dev/null | sort); do
  repo_dir=$(dirname "$git_file")
  
  # For worktrees, include the parent directory in the name to distinguish them
  parent_dir=$(basename $(dirname "$repo_dir"))
  worktree_name=$(basename "$repo_dir")
  
  # Create a descriptive name for the worktree
  if [[ "$parent_dir" != "workspace" ]]; then
    repo_name="${parent_dir}/${worktree_name}"
  else
    repo_name="$worktree_name"
  fi
  
  process_repo "$repo_dir" "$repo_name"
done

# Sort entries by project name, then by branch
IFS=$'\n' sorted_entries=($(sort -t'|' -k1,1 -k2,2 <<< "${all_entries[*]}"))

# Print table
echo "| Project | Branch | Commits | Summary |"
echo "|---------|--------|---------|---------|"

if [[ $found -eq 0 ]]; then
  echo "| -       | -      | -       | No commits found for yesterday |"
else
  for entry in "${sorted_entries[@]}"; do
    IFS='|' read -r project branch commits summary <<< "$entry"
    # Truncate long values to fit table
    project=${project:0:20}
    branch=${branch:0:20}
    summary=${summary:0:40}
    printf "| %-20s | %-20s | %-7s | %-40s |\n" "$project" "$branch" "$commits" "$summary"
  done
fi

# Add blank line after the table
echo ""