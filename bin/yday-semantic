#!/bin/zsh
# yday-semantic - Show git activity with semantic summaries using git-standup

# Default parent directory and behavior
parent_dir="$HOME/workspace"
show_all=false
days_back=""  # Let git-standup handle the default
show_today=false
custom_days=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --all)
      show_all=true
      days_back=7  # Show last week for --all
      shift
      ;;
    --today)
      show_today=true
      days_back=0
      shift
      ;;
    --parent=*)
      parent_dir="${1#*=}"
      # Expand tilde
      parent_dir="${parent_dir/#\~/$HOME}"
      shift
      ;;
    -d|--days)
      days_back="$2"
      custom_days=true
      shift 2
      ;;
    *)
      echo "Usage: $0 [--all] [--today] [--parent=<directory>] [-d|--days <number>]"
      echo "  --all: Show last week's activity"
      echo "  --today: Show today's activity"
      echo "  --parent=<dir>: Directory to search for git repos (default: ~/workspace)"
      echo "  -d, --days <n>: Number of days back to look"
      echo ""
      echo "Default behavior: Shows yesterday's commits (or Friday's on Monday)"
      exit 1
      ;;
  esac
done

# If no flags set, calculate the correct days back for "yesterday"
if [[ -z "$days_back" ]]; then
  # Default mode: true yesterday (or Friday on Monday)
  local day_of_week=$(date +%A)
  if [[ "$day_of_week" == "Monday" ]]; then
    standup_flags="-d 3 -u 3"  # Friday only
  else
    standup_flags="-d 1 -u 1"  # Yesterday only
  fi
elif [[ $days_back -eq 0 ]]; then
  standup_flags="-d 0 -u 0"  # Today only
else
  standup_flags="-d $days_back"  # Last N days (including today)
fi

# Check if git-standup is installed
if ! command -v git-standup &> /dev/null; then
  echo "Error: git-standup is not installed."
  echo "Install it with: npm install -g git-standup"
  echo "Or visit: https://github.com/kamranahmedse/git-standup"
  exit 1
fi

# Function to generate semantic summary
generate_semantic_summary() {
  local messages="$1"
  local project="$2"
  
  # Clean up messages: remove common prefixes and noise
  local clean_messages=$(echo "$messages" | \
    sed 's/^Merge pull request.*$//' | \
    sed 's/^Merge branch.*$//' | \
    sed 's/^WIP[[:space:]]*://' | \
    sed 's/^[Ff]ix[[:space:]]*://' | \
    sed 's/^[Aa]dd[[:space:]]*://' | \
    sed 's/^[Uu]pdate[[:space:]]*://' | \
    sed 's/^[Ff]eat[[:space:]]*://' | \
    sed 's/^[Ff]eature[[:space:]]*://' | \
    sed 's/^chore://' | \
    sed 's/^refactor://' | \
    sed '/^[[:space:]]*$/d')
  
  # Look for specific high-level features and epics
  local summary=""
  
  # Check for app/feature names and major components first
  if echo "$clean_messages" | grep -i -q -E '\b(watch|watchOS|apple watch|watch app)\b'; then
    summary="Watch app development"
  elif echo "$clean_messages" | grep -i -q -E '\b(swarm|docker|container|deployment|deploy)\b'; then
    summary="Deployment/containerization"
  elif echo "$clean_messages" | grep -i -q -E '\b(test|testing|spec|rspec|jest|cypress)\b'; then
    summary="Testing improvements"
  elif echo "$clean_messages" | grep -i -q -E '\b(error|exception|handling|validation)\b'; then
    summary="Error handling"
  elif echo "$clean_messages" | grep -i -q -E '\b(authentication|auth|login|signup|oauth)\b'; then
    summary="Authentication system"
  elif echo "$clean_messages" | grep -i -q -E '\b(ui|interface|theme|styling|design|layout)\b'; then
    summary="UI/design work"
  elif echo "$clean_messages" | grep -i -q -E '\b(api|endpoint|controller|service|backend)\b'; then
    summary="API development"
  elif echo "$clean_messages" | grep -i -q -E '\b(database|migration|model|schema)\b'; then
    summary="Database work"
  elif echo "$clean_messages" | grep -i -q -E '\b(performance|optimization|speed|cache)\b'; then
    summary="Performance optimization"
  elif echo "$clean_messages" | grep -i -q -E '\b(navigation|routing|menu)\b'; then
    summary="Navigation/routing"
  elif echo "$clean_messages" | grep -i -q -E '\b(payment|stripe|billing|subscription)\b'; then
    summary="Payment integration"
  elif echo "$clean_messages" | grep -i -q -E '\b(notification|email|message|alert)\b'; then
    summary="Notifications/messaging"
  elif echo "$clean_messages" | grep -i -q -E '\b(search|filter|pagination|sort)\b'; then
    summary="Search/filtering"
  elif echo "$clean_messages" | grep -i -q -E '\b(mobile|ios|android|responsive)\b'; then
    summary="Mobile development"
  elif echo "$clean_messages" | grep -i -q -E '\b(configuration|config|setup|install)\b'; then
    summary="Configuration/setup"
  elif echo "$clean_messages" | grep -i -q -E '\b(security|permission|access|role)\b'; then
    summary="Security/permissions"
  elif echo "$clean_messages" | grep -i -q -E '\b(integration|webhook|third.party|external)\b'; then
    summary="Third-party integration"
  elif echo "$clean_messages" | grep -i -q -E '\b(script|automation|tool|utility|helper)\b'; then
    summary="Development tooling"
  elif echo "$clean_messages" | grep -i -q -E '\b(documentation|docs|readme|guide)\b'; then
    summary="Documentation"
  elif echo "$clean_messages" | grep -i -q -E '\b(refactor|cleanup|maintenance|reorganize)\b'; then
    summary="Code maintenance"
  elif echo "$clean_messages" | grep -i -q -E '\b(rails|ruby|gem|bundler)\b'; then
    summary="Rails development"
  elif echo "$clean_messages" | grep -i -q -E '\b(vscode|editor|titlebar|extension)\b'; then
    summary="Editor/IDE setup"
  else
    # Fall back to extracting key nouns from commit messages
    local key_nouns=$(echo "$clean_messages" | \
      grep -i -o -E '\b[A-Z][A-Za-z]{3,}|[a-z]{4,}' | \
      grep -v -E '^(with|from|into|this|that|have|been|were|will|your|their|them|they|when|where|what|which|also|some|work|more|commit|change|update|file|code|line|text|data|info|item|part|side|main|full|auto|very|most|many|much|less|same|other|each|every|only|just|first|last|next|prev|good|better|best|new|old|small|large|quick|simple|basic|advanced|complete|final|initial|original|current|latest|recent)$' -i | \
      sort | uniq -c | sort -nr | head -2 | awk '{print $2}')
    
    if [[ -n "$key_nouns" ]]; then
      summary=$(echo "$key_nouns" | tr '\n' ' ' | sed 's/ $//' | sed 's/^[[:space:]]*//')
    else
      # Last resort: use first meaningful commit message
      summary=$(echo "$clean_messages" | head -1 | cut -c 1-25)
    fi
  fi
  
  # Clean up and ensure proper capitalization
  summary=$(echo "$summary" | sed 's/[[:space:]]\+/ /g' | sed 's/^ *//' | sed 's/ *$//')
  
  # Limit length and return
  if [[ ${#summary} -gt 35 ]]; then
    echo "${summary:0:32}..."
  else
    echo "$summary"
  fi
}

# Function to get relative time description
get_time_description() {
  if [[ -z "$days_back" ]]; then
    # Default mode: git-standup's smart handling
    local day_of_week=$(date +%A)
    if [[ "$day_of_week" == "Monday" ]]; then
      echo "Friday, $(date -v-3d +%A\ %B\ %d)"
    else
      echo "yesterday, $(date -v-1d +%A\ %B\ %d)"
    fi
  elif [[ $days_back -eq 0 ]]; then
    echo "today, $(date +%A\ %B\ %d)"
  elif [[ $days_back -eq 1 ]]; then
    echo "yesterday, $(date -v-1d +%A\ %B\ %d)"
  elif [[ $days_back -eq 7 ]]; then
    echo "last week"
  else
    echo "last $days_back days"
  fi
}

# Change to parent directory
cd "$parent_dir" 2>/dev/null || {
  echo "Error: Cannot access directory $parent_dir"
  exit 1
}

echo "## Git Repository Activity in \`$parent_dir\` ($(get_time_description))..."
echo ""

# Run git-standup and capture output
standup_output=$(git-standup $standup_flags 2>/dev/null)


if [[ -z "$standup_output" ]]; then
  echo "| Repo | Commits | Summary |"
  echo "|------|---------|---------|"
  echo "| -    | -       | No commits found for $(get_time_description) |"
  echo ""
  exit 0
fi

# Initialize arrays for table data
declare -A repo_commits
declare -A repo_summaries
all_repos=()

# Parse git-standup output
current_repo=""
current_commits=""

while IFS= read -r line; do
  # Skip empty lines
  [[ -z "$line" ]] && continue
  
  # Check if this is a repository header (starts with /, contains git repos)
  if [[ "$line" =~ ^/.*/([^/]+)$ ]]; then
    # Save previous repo data if we have it
    if [[ -n "$current_repo" && -n "$current_commits" ]]; then
      commit_count=$(echo "$current_commits" | grep -c '^.')  # Count non-empty lines
      repo_commits[$current_repo]=$commit_count
      repo_summaries[$current_repo]=$(generate_semantic_summary "$current_commits" "$current_repo")
      all_repos+=("$current_repo")
      
    fi
    
    # Extract repo name from path
    current_repo=$(basename "$line")
    current_commits=""
    continue
  fi
  
  # Check if this line contains commit info (starts with hash and has " - ")
  if [[ "$line" =~ ^[a-f0-9]+.*\ -\  ]]; then
    # Simple approach: split on " - " and take everything after
    commit_message="${line#*\ -\ }"
    # Remove the timestamp and author info at the end - keep everything before " (X ago)"
    commit_message=$(echo "$commit_message" | sed 's/ ([^)]* ago) <[^>]*>.*$//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
    current_commits+="$commit_message"$'\n'
    
    continue
  fi
  
  # Skip lines like "No commits from JPB during this period."
done <<< "$standup_output"

# Don't forget the last repo
if [[ -n "$current_repo" && -n "$current_commits" ]]; then
  commit_count=$(echo "$current_commits" | grep -c '^.')  # Count non-empty lines
  repo_commits[$current_repo]=$commit_count
  repo_summaries[$current_repo]=$(generate_semantic_summary "$current_commits" "$current_repo")
  all_repos+=("$current_repo")
fi

# Sort repos alphabetically
IFS=$'\n' sorted_repos=($(sort <<< "${all_repos[*]}"))

# Calculate column widths
max_repo=4      # "Repo"
max_commits=7   # "Commits"
max_summary=7   # "Summary"

for repo in "${sorted_repos[@]}"; do
  [[ ${#repo} -gt $max_repo ]] && max_repo=${#repo}
  commits=${repo_commits[$repo]}
  [[ ${#commits} -gt $max_commits ]] && max_commits=${#commits}
  summary=${repo_summaries[$repo]}
  [[ ${#summary} -gt $max_summary ]] && max_summary=${#summary}
done

# Cap maximum widths for readability
[[ $max_repo -gt 30 ]] && max_repo=30
[[ $max_summary -gt 50 ]] && max_summary=50

# Print table
printf "| %-${max_repo}s | %-${max_commits}s | %-${max_summary}s |\n" "Repo" "Commits" "Summary"

# Print separator line
printf "|"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_repo + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_commits + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_summary + 2))))"
printf "\n"

if [[ ${#sorted_repos[@]} -eq 0 ]]; then
  printf "| %-${max_repo}s | %-${max_commits}s | %-${max_summary}s |\n" \
    "-" "-" "No commits found for $(get_time_description)"
else
  for repo in "${sorted_repos[@]}"; do
    commits=${repo_commits[$repo]}
    summary=${repo_summaries[$repo]}
    
    # Truncate if needed
    repo=${repo:0:$max_repo}
    summary=${summary:0:$max_summary}
    
    printf "| %-${max_repo}s | %-${max_commits}s | %-${max_summary}s |\n" \
      "$repo" "$commits" "$summary"
  done
fi

# Add blank line after the table
echo ""