#!/bin/zsh
# yday-semantic - Show git activity with semantic summaries using git-standup

# Default parent directory and behavior
parent_dir="$HOME/workspace"
show_all=false
days_back=""  # Let git-standup handle the default
show_today=false
custom_days=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --all)
      show_all=true
      days_back=7  # Show last week for --all
      shift
      ;;
    --today)
      show_today=true
      days_back=0
      shift
      ;;
    --parent=*)
      parent_dir="${1#*=}"
      # Expand tilde
      parent_dir="${parent_dir/#\~/$HOME}"
      shift
      ;;
    -d|--days)
      days_back="$2"
      custom_days=true
      shift 2
      ;;
    *)
      echo "Usage: $0 [--all] [--today] [--parent=<directory>] [-d|--days <number>]"
      echo "  --all: Show last week's activity"
      echo "  --today: Show today's activity"
      echo "  --parent=<dir>: Directory to search for git repos (default: ~/workspace)"
      echo "  -d, --days <n>: Number of days back to look"
      echo ""
      echo "Default behavior: Shows yesterday's commits (or Friday's on Monday)"
      exit 1
      ;;
  esac
done

# If no flags set, calculate the correct days back for "yesterday"
if [[ -z "$days_back" ]]; then
  # Default mode: true yesterday (or Friday on Monday)
  local day_of_week=$(date +%A)
  if [[ "$day_of_week" == "Monday" ]]; then
    standup_flags="-d 3 -u 3"  # Friday only
  else
    standup_flags="-d 1 -u 1"  # Yesterday only
  fi
elif [[ $days_back -eq 0 ]]; then
  standup_flags="-d 0 -u 0"  # Today only
else
  standup_flags="-d $days_back"  # Last N days (including today)
fi

# Check if git-standup is installed
if ! command -v git-standup &> /dev/null; then
  echo "Error: git-standup is not installed."
  echo "Install it with: npm install -g git-standup"
  echo "Or visit: https://github.com/kamranahmedse/git-standup"
  exit 1
fi

# Function to generate semantic summary
generate_semantic_summary() {
  local messages="$1"
  local project="$2"
  
  # Use the semantic_summarize script if available
  if [[ -x ~/workspace/dot-rot/bin/semantic_summarize ]]; then
    summary=$(echo "$messages" | ~/workspace/dot-rot/bin/semantic_summarize "$project" 2>/dev/null)
    if [[ -n "$summary" ]]; then
      echo "$summary"
      return
    fi
  fi
  
  # Fallback: extract keywords
  keywords=$(echo "$messages" | \
    grep -o -E '\b[a-zA-Z]{4,}\b' | \
    grep -v -E '^(with|from|into|this|that|have|been|were|will|your|their|them|they|when|where|what|which|also|some|work|more|commit|added|fixed|changed|update|updated)$' -i | \
    sort | uniq -c | sort -nr | head -3 | \
    awk '{print $2}' | tr '\n' ' ' | sed 's/ $//')
  
  if [[ -n "$keywords" ]]; then
    echo "$keywords"
  else
    echo "$messages" | head -1 | cut -c 1-30
  fi
}

# Function to get relative time description
get_time_description() {
  if [[ -z "$days_back" ]]; then
    # Default mode: git-standup's smart handling
    local day_of_week=$(date +%A)
    if [[ "$day_of_week" == "Monday" ]]; then
      echo "Friday ($(date -v-3d +%m/%d))"
    else
      echo "yesterday ($(date -v-1d +%m/%d))"
    fi
  elif [[ $days_back -eq 0 ]]; then
    echo "today ($(date +%m/%d))"
  elif [[ $days_back -eq 1 ]]; then
    echo "yesterday ($(date -v-1d +%m/%d))"
  elif [[ $days_back -eq 7 ]]; then
    echo "last week"
  else
    echo "last $days_back days"
  fi
}

# Change to parent directory
cd "$parent_dir" 2>/dev/null || {
  echo "Error: Cannot access directory $parent_dir"
  exit 1
}

echo "## Git Repository Activity in \`$parent_dir\` ($(get_time_description))..."
echo ""

# Run git-standup and capture output
standup_output=$(git-standup $standup_flags 2>/dev/null)


if [[ -z "$standup_output" ]]; then
  echo "| Repo | Commits | Summary |"
  echo "|------|---------|---------|"
  echo "| -    | -       | No commits found for $(get_time_description) |"
  echo ""
  exit 0
fi

# Initialize arrays for table data
declare -A repo_commits
declare -A repo_summaries
all_repos=()

# Parse git-standup output
current_repo=""
current_commits=""

while IFS= read -r line; do
  # Skip empty lines
  [[ -z "$line" ]] && continue
  
  # Check if this is a repository header (starts with /, contains git repos)
  if [[ "$line" =~ ^/.*/([^/]+)$ ]]; then
    # Save previous repo data if we have it
    if [[ -n "$current_repo" && -n "$current_commits" ]]; then
      commit_count=$(echo "$current_commits" | grep -c '^.')  # Count non-empty lines
      repo_commits[$current_repo]=$commit_count
      repo_summaries[$current_repo]=$(generate_semantic_summary "$current_commits" "$current_repo")
      all_repos+=("$current_repo")
      
    fi
    
    # Extract repo name from path
    current_repo=$(basename "$line")
    current_commits=""
    continue
  fi
  
  # Check if this line contains commit info (starts with hash and has " - ")
  if [[ "$line" =~ ^[a-f0-9]+.*\ -\  ]]; then
    # Simple approach: split on " - " and take everything after
    commit_message="${line#*\ -\ }"
    # Remove the timestamp and author info at the end - keep everything before " (X ago)"
    commit_message=$(echo "$commit_message" | sed 's/ ([^)]* ago) <[^>]*>.*$//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
    current_commits+="$commit_message"$'\n'
    
    continue
  fi
  
  # Skip lines like "No commits from JPB during this period."
done <<< "$standup_output"

# Don't forget the last repo
if [[ -n "$current_repo" && -n "$current_commits" ]]; then
  commit_count=$(echo "$current_commits" | grep -c '^.')  # Count non-empty lines
  repo_commits[$current_repo]=$commit_count
  repo_summaries[$current_repo]=$(generate_semantic_summary "$current_commits" "$current_repo")
  all_repos+=("$current_repo")
fi

# Sort repos alphabetically
IFS=$'\n' sorted_repos=($(sort <<< "${all_repos[*]}"))

# Calculate column widths
max_repo=4      # "Repo"
max_commits=7   # "Commits"
max_summary=7   # "Summary"

for repo in "${sorted_repos[@]}"; do
  [[ ${#repo} -gt $max_repo ]] && max_repo=${#repo}
  commits=${repo_commits[$repo]}
  [[ ${#commits} -gt $max_commits ]] && max_commits=${#commits}
  summary=${repo_summaries[$repo]}
  [[ ${#summary} -gt $max_summary ]] && max_summary=${#summary}
done

# Cap maximum widths for readability
[[ $max_repo -gt 30 ]] && max_repo=30
[[ $max_summary -gt 50 ]] && max_summary=50

# Print table
printf "| %-${max_repo}s | %-${max_commits}s | %-${max_summary}s |\n" "Repo" "Commits" "Summary"

# Print separator line
printf "|"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_repo + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_commits + 2))))"
printf "%s|" "$(printf '%.0s-' $(seq 1 $((max_summary + 2))))"
printf "\n"

if [[ ${#sorted_repos[@]} -eq 0 ]]; then
  printf "| %-${max_repo}s | %-${max_commits}s | %-${max_summary}s |\n" \
    "-" "-" "No commits found for $(get_time_description)"
else
  for repo in "${sorted_repos[@]}"; do
    commits=${repo_commits[$repo]}
    summary=${repo_summaries[$repo]}
    
    # Truncate if needed
    repo=${repo:0:$max_repo}
    summary=${summary:0:$max_summary}
    
    printf "| %-${max_repo}s | %-${max_commits}s | %-${max_summary}s |\n" \
      "$repo" "$commits" "$summary"
  done
fi

# Add blank line after the table
echo ""