#!/bin/zsh
# yday-semantic - Show git activity with semantic summaries

# Get yesterday's date
yesterday=$(date -v-1d +"%Y-%m-%d")
today=$(date +"%Y-%m-%d")

# Initialize arrays
declare -A seen_entries  # To track duplicates
all_entries=()
found=0

echo "## Yesterday in Git ($yesterday)..."
echo ""

# Function to generate semantic summaries using Claude
generate_semantic_summary() {
  local messages="$1"
  local project="$2"
  
  # For now, disable claude CLI due to timeout issues
  # Just use improved keyword extraction
  if false; then
    # Claude CLI disabled for now
    :
  else
    # Fallback: extract meaningful keywords
    keywords=$(echo "$messages" | \
      grep -o -E '\b[a-zA-Z]{4,}\b' | \
      grep -v -E '^(with|from|into|this|that|have|been|were|will|your|their|them|they|when|where|what|which|update|updated|commit|added|fixed|changed)$' | \
      sort | uniq -c | sort -nr | head -3 | \
      awk '{print $2}' | tr '\n' ' ' | sed 's/ $//')
    
    if [[ -n "$keywords" ]]; then
      echo "$keywords"
    else
      # Use first commit message
      echo "$messages" | head -1 | cut -c 1-30
    fi
  fi
}

# Function to process a git repository
process_repo() {
  local repo_dir="$1"
  local repo_name="$2"
  
  # Get all local branches using git -C to avoid changing directories
  branches=$(git -C "$repo_dir" for-each-ref --format='%(refname:short)' refs/heads/ 2>/dev/null)
  
  while IFS= read -r branch; do
    # Skip empty branch names
    [[ -z "$branch" ]] && continue
    
    # Get yesterday's commits for this branch
    commits=$(git -C "$repo_dir" log "$branch" --oneline --after="$yesterday 00:00" --before="$today 00:00" 2>/dev/null)
    
    if [[ -n "$commits" ]]; then
      commit_count=$(echo "$commits" | wc -l | tr -d ' ')
      commit_messages=$(echo "$commits" | sed 's/^[^ ]* //')
      
      # Create unique key to check for duplicates
      entry_key="${repo_name}|${branch}|${commit_count}"
      
      # Skip if we've already seen this exact entry
      if [[ -z "${seen_entries[$entry_key]}" ]]; then
        seen_entries[$entry_key]=1
        summary=$(generate_semantic_summary "$commit_messages" "$repo_name")
        
        # Add entry for this branch
        all_entries+=("$repo_name|$branch|$commit_count|$summary")
        ((found++))
      fi
    fi
  done <<< "$branches"
}

# First pass - standard git repositories
for repo_path in $(find ~/workspace -type d -name ".git" -maxdepth 3 2>/dev/null | sort); do
  repo_dir=$(dirname "$repo_path")
  repo_name=$(basename "$repo_dir")
  
  # Skip if it's the workspace directory itself
  [[ "$repo_name" == "workspace" ]] && continue
  
  process_repo "$repo_dir" "$repo_name"
done

# Second pass - git worktrees (where .git is a file)
for git_file in $(find ~/workspace -type f -name ".git" -maxdepth 3 2>/dev/null | sort); do
  repo_dir=$(dirname "$git_file")
  
  # For worktrees, just use the directory name
  repo_name=$(basename "$repo_dir")
  
  process_repo "$repo_dir" "$repo_name"
done

# Sort entries by project name, then by branch
IFS=$'\n' sorted_entries=($(sort -t'|' -k1,1 -k2,2 <<< "${all_entries[*]}"))

# Calculate column widths for proper formatting
max_project=7  # "Project"
max_branch=6   # "Branch"
max_commits=7  # "Commits"
max_summary=7  # "Summary"

# Find maximum widths
for entry in "${sorted_entries[@]}"; do
  IFS='|' read -r project branch commits summary <<< "$entry"
  [[ ${#project} -gt $max_project ]] && max_project=${#project}
  [[ ${#branch} -gt $max_branch ]] && max_branch=${#branch}
  [[ ${#summary} -gt $max_summary ]] && max_summary=${#summary}
done

# Cap maximum widths for readability
[[ $max_project -gt 25 ]] && max_project=25
[[ $max_branch -gt 20 ]] && max_branch=20
[[ $max_summary -gt 40 ]] && max_summary=40

# Print table header
printf "| %-${max_project}s | %-${max_branch}s | %-${max_commits}s | %-${max_summary}s |\n" "Project" "Branch" "Commits" "Summary"

# Print separator line
printf "|"
printf "%s" "$(printf '%.0s-' $(seq 1 $((max_project + 2))))|"
printf "%s" "$(printf '%.0s-' $(seq 1 $((max_branch + 2))))|"
printf "%s" "$(printf '%.0s-' $(seq 1 $((max_commits + 2))))|"
printf "%s" "$(printf '%.0s-' $(seq 1 $((max_summary + 2))))|"
printf "\n"

if [[ $found -eq 0 ]]; then
  printf "| %-${max_project}s | %-${max_branch}s | %-${max_commits}s | %-${max_summary}s |\n" \
    "-" "-" "-" "No commits found for yesterday"
else
  for entry in "${sorted_entries[@]}"; do
    IFS='|' read -r project branch commits summary <<< "$entry"
    # Truncate if needed
    project=${project:0:$max_project}
    branch=${branch:0:$max_branch}
    summary=${summary:0:$max_summary}
    printf "| %-${max_project}s | %-${max_branch}s | %-${max_commits}s | %-${max_summary}s |\n" \
      "$project" "$branch" "$commits" "$summary"
  done
fi

# Add blank line after the table
echo ""