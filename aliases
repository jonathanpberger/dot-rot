# This probably wants to go in ~/.oh-my-zsh/custom/aliases.zsh

echo "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ Loading aliases â€¢â€¢â€¢ $(date "+%a %b %d %H:%M:%S"): "

# Generally helpful
alias hg="history | grep"
alias g="gcalcli"
alias be="bundle exec"
alias old-gday="echo '## ðŸª¢ Todo Today\n\n|Time|Item|\n|---|---|\n' & gcalcli --cal 'JPB-DW' --cal 'Pomo' --cal 'JPB SL' --cal 'JPB Private' agenda yesterday tomorrow --no-military"

alias pomo="pomodoro"
alias vi="nvim"
alias vim="nvim"

# Navigation
alias vscode-global="cd ~/Library/Application\ Support/Code/User/"
alias dotrot="cd ~/workspace/dot-rot"

# Some alias / shell housekeeping
alias zr="source ~/.zshrc"
alias ze="vi ~/.zshrc"
alias za="vi ~/.oh-my-zsh/custom/aliases.zsh"

# An alias for dvorak typists
alias aoeu='asdf'

# Some todo apps
alias t='reminders'
alias ta='reminders add'
alias td='reminders complete Reminders'
alias rsl='reminders show-lists'
alias tl='reminders show Reminders'

# `Now.md` convenience methods
alias todos="ack '^.[^|\[]\[[^x]\]\s\w' ~/Dropbox/Notes-and-docs/JPB-monthly-notes/foam/now.md -C2"
alias prev-todos="ack '^.[^|\[]\[[^x]\]\s\w' prev.md -C2"
alias h2s="ack '^\#{2}\s' ~/Dropbox/Notes-and-docs/JPB-monthly-notes/foam/now.md -C1"
alias projects="ack  '(\+\+\w.*)'  ~/Dropbox/Notes-and-docs/JPB-monthly-notes/foam/now.md --output '$1'"
alias prev-projects="ack  '(\+\+\w.*)'  ~/Dropbox/Notes-and-docs/JPB-monthly-notes/foam/prev.md --output '$1'"
alias foam="cd ~/Dropbox/Notes-and-docs/JPB-monthly-notes/foam"

# alias ghi="echo '########## JPB Github Issues copied to clipboard :-) ##########\n' && gh search issues --assignee=@me --state=open --limit=333 | pbcopy"

# Github CLI
function pmtl() {
  local headers="|Order | Status | Title | Project | Link|\n|---|---|---|---|---|"

  local result=$(gh p item-list 36 --limit 300 --format=json | jq -r '(.items | to_entries | map(select((.value.status == "In progress" or .value.status == "Backlog" or .value.status == "Waiting") and (.value.assignees[]? | contains("jonathanpberger"))))) | .[] | "| \(.key+1) | \(.value.status) | \(.value.title) | \(.value["project ðŸªš"]) | \((.value.content.repository | split("/")[-1]) + "/" + (.value.content.number|tostring)) |"')

  echo -e "### SL PM Tasks"
  echo -e "$headers"
  echo "$result"
  echo -e "$headers\n$result" | pbcopy
}
# ######### this works
#
# function gordtl() {
#   local headers="|Title|Status|url|Assignees|\n|--|--|--|--|"
#   local result=$(gh p item-list 47 --limit 22 --format=json | jq -r '.items[] | "| \(.title) | \(.status) |\(.content.url) | \(.assignees // [] | if type == "array" then map(if type == "object" then .login else . end) else [] end | join(", ")) |"')

#   echo -e "### Gordian Tasks"
#   echo -e "$headers"
#   echo "$result"
#   echo -e "$headers\n$result" | pbcopy
# }
# #########

function gordtl() {
  echo "Version 0.42"
  local headers="|Order|Status|Title|URL|Assignees|\n|--|--|--|--|--|"
  local result=$(gh p item-list 47 --format=json | jq -r '.items | to_entries[] | "| \(.key + 1) | \(.value.status) | \(.value.title) | \(.value.content.url) | \(.value.assignees // [] | if type == "array" then map(if type == "object" then .login else . end) else [] end | join(", ")) |"')

  local count=$(echo "$result" | wc -l | tr -d ' ')

  echo -e "### Gordian Tasks"
  echo -e "$headers\n$result"
  echo -e "$headers\n$result" | pbcopy
  echo -e "\n\n********* Gordian Tasks have been copied to the clipboard. There are $count tasks. :-) ###\n"
}



function ghtl() {
  local headers="|Order | Status | Title | url|"
  local separators="|$(echo "$headers" | sed 's/[^|]//g' | sed 's/|/---|/g' | sed 's/|$//')"

  local result=$(gh p item-list 46 --limit 300 --format=json | jq -r '(.items | to_entries | map(select((.value.status == "In progress" or .value.status == "Backlog" or .value.status == "Waiting") and (.value.assignees[]? | contains("jonathanpberger"))))) | .[] | "| \(.key+1) | \(.value.status) | \(.value.title) | \((.value.content.repository | split("/")[-1]) + "/" + (.value.content.number|tostring)) |"')

  echo -e "### README.lint Tasks"
  echo -e "$headers"
  echo -e "$separators"
  echo "$result"
  echo -e "$headers\n$result" | pbcopy
}

function ghi() {
  local user=$(gh api /user | jq -r '.login')
  local header="| Repository | Number | State | Title |url|"
  local separator="|------------|--------|-------|-----|--|"
  local results=$(gh search issues --assignee=@me --state=open --limit 333 --include-prs --json="repository,number,state,title,url" | jq -r '.[] | "| \(.repository.name) | \(.number) | \(.state) | \(.title) | \(.url) |"')
  local count=$(echo "$results" | wc -l | tr -d ' ')
  local title="### $count Open GitHub Issues for @$user"

  echo "$title"
  echo "$header"
  echo "$separator"
  echo "$results"

  echo -e "$title\n$header\n$separator\n$results" | pbcopy
  echo -e "\n$title have been copied to the clipboard. There are $count issues. :-) ###"
}
function gday() {
    # Version 9.6
    local title="## ðŸª¢ Todo Today"
    local header="| Time    | Item |"
    local separator="|---------|------|"
    local output=$(gcalcli --cal "JPB-DW" --cal "Pomo" --cal "JPB SL" --cal "JPB Private" agenda "today" "tomorrow" --nocolor --no-military)

    # Remove ANSI color codes
    local no_color_output=$(echo "$output" | sed 's/\x1b\[[0-9;]*m//g')

    # Process the output line by line
    local body=$(echo "$no_color_output" | awk '{
        # Trim leading whitespace for the whole line
        gsub(/^[ \t]+/, "", $0);
        # If the line starts with a non-number (the date line), remove everything up to the time
        if ($0 ~ /^[^0-9]/) {
            sub(/.*[0-9]{1,2}:[0-9]{2}[apm]{2}[ \t]+/, "", $0);
        }
        # Check if the line has a valid time format now, and if so, process it
        if ($0 ~ /^[0-9]{1,2}:[0-9]{2}[apm]{2}/) {
            # Extract the time and item
            time = $1;
            $1 = ""; # Remove the time field to concatenate the rest
            item = $0;
            # Print pipe, time, pipe, item, pipe
            print "| " time " | " item " |";
        }
    }')

    echo -e "$title\n$header\n$separator\n$body"
}

alias ttl="pmtl \n\n && gordtl \n\n && ghtl"

# alltl function v0.1
# Retrieves a combined list of all GitHub issues assigned to me and their project status.
# Depends on GitHub CLI (`gh`) and `jq` for processing JSON.

function alltl() {
  # Get list of issues assigned to me
  local issues=$(gh issue list --assignee @me --json number,title,repository --jq '.[] | {number, title, repo: .repository.nameWithOwner}')

  # Get list of projects I'm a member of
  local projects=$(gh api graphql -f query='
    {
      viewer {
        projectsV2(first: 10) {
          nodes {
            name
            items(first: 100) {
              nodes {
                content {
                  ... on Issue {
                    number
                  }
                }
                fieldValues(first: 10) {
                  nodes {
                    projectField {
                      name
                    }
                    value
                  }
                }
              }
            }
          }
        }
      }
    }' --jq '.data.viewer.projectsV2.nodes[] | {project: .name, items: [.items.nodes[] | {number: .content.number, status: (.fieldValues.nodes[] | select(.projectField.name == "Status") | .value)]}}')

  # Synthesize table with combined data
  local header="| Title | Repo Name / Issue Number | Assigned Project | Status |"
  local separator="|-------|-------------------------|------------------|--------|"
  echo "$header"
  echo "$separator"

  for issue in $(echo "$issues" | jq -c '.'); do
    local issue_number=$(echo "$issue" | jq -r '.number')
    local issue_title=$(echo "$issue" | jq -r '.title')
    local issue_repo=$(echo "$issue" | jq -r '.repo')
    local project_name="none"
    local status="none"

    # Check projects for this issue
    for project in $(echo "$projects" | jq -c '.'); do
      local p_name=$(echo "$project" | jq -r '.project')
      local p_issue=$(echo "$project" | jq --arg number "$issue_number" '.items[] | select(.number == ($number | tonumber))')
      if [ "$p_issue" != "" ]; then
        if [ "$project_name" == "none" ]; then
          project_name=$p_name
          status=$(echo "$p_issue" | jq -r '.status')
        else
          project_name="many"
          status="many"
          break
        fi
      fi
    done

    echo "| $issue_title | $issue_repo / $issue_number | $project_name | $status |"
  done | column -t -s '|'

  echo "Table has been synthesized."
}

function collect_field_names() {
  local version="v0.4"

  # Emit the version information
  echo "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ collect_field_names [$version] â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"

  # Retrieve and map the project names to their numbers
  local project_info=$(gh project list --owner strangelove-ventures --format json ) | jq -r '[.[] | {number, name}]'

  # Define the list of project numbers
  local project_numbers=(46 49 39 36 34 30 24 18)

  # Iterate over the project numbers to retrieve and print field names
  for project_number in $project_numbers; do
    # Extract the project name using the project number
    local project_name=$(echo "$project_info" | jq -r --argjson number $project_number '.[] | select(.number == $number) | .name')

    # Print the project name
    echo "Project $project_number ($project_name) fields:"

    # Retrieve and print the field names for the project
    gh project field-list $project_number --owner strangelove-ventures --format json |
      jq -r '[.fields[].name] | join(", ")'
    echo # Print a newline for better readability
  done
}

function ppi() {
  echo "Version 0.3.3"

  # Fetch Gordian tasks.
  local gordianTasks=$(gh p item-list 47 --format=json | jq -r '
    .items | map({
      order: .order,
      status: .status,
      title: .title,
      url: .content.url,
      # Directly join the assignees array to a string, if it is not an array, set to an empty string.
      assignees: (.assignees | if type == "array" then join(", ") else "" end)
    })'
  )

  # Fetch GitHub issues.
  local gitHubIssues=$(gh search issues --assignee=@me --state=open --limit=333 --include-prs --json="repository,number,state,title,url" | jq -r '.[] | {repository: .repository.name, number: .number, state: .state, title: .title, url: .url}')

  # Combine Gordian tasks and GitHub issues based on URL.
  local combinedResults=$(jq -s 'flatten | group_by(.url) | map({
    url: .[0].url,
    title: .[0].title,
    status: .[0].status,
    assignees: .[0].assignees,
    repository: (.[1] // {}).repository,
    number: (.[1] // {}).number,
    state: (.[1] // {}).state
  })' <(echo "$gordianTasks") <(echo "$gitHubIssues"))
  local combinedTable=$(echo "$combinedResults" | jq -r '.[] | "| \(.url) | \(.title) | \(.status) | \(.assignees) | \(.repository) | \(.number) | \(.state) |"')

  # Count the results.
  local count=$(echo "$combinedResults" | jq 'length')
  local title="### Combined Gordian Tasks and GitHub Issues for @$user"

  # Print the combined table header.
  local tableHeader=$(echo "|URL|Title|Status|Assignees|Repository|Issue Number|Issue State|")
  local separator=$(echo "|---|-----|------|---------|----------|------------|-----------|")

  echo -e "$title\n$tableHeader\n$separator\n$combinedTable"

  # Copy the combined results to the clipboard.
  echo -e "$title\n$tableHeader\n$separator\n$combinedTable" | pbcopy
  echo -e "\n$title have been copied to the clipboard. There are $count combined tasks and issues. :-) ###"
}

echo "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ Finished Loading aliases!\n\n"
