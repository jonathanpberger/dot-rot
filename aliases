# This probably wants to go in ~/.oh-my-zsh/custom/aliases.zsh

echo "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ Loading aliases â€¢â€¢â€¢ $(date "+%a %b %d %H:%M:%S") "

# Generally helpful
alias hg="history | grep"
alias g="gcalcli"
alias be="bundle exec"

alias pomo="pomodoro"
alias vi="nvim"
alias vim="nvim"

# Navigation
alias vscode-global="cd ~/Library/Application\ Support/Code/User/"
alias dotrot="cd ~/workspace/dot-rot"

# Some alias / shell housekeeping
alias zr="source ~/.zshrc"
alias ze="code ~/.zshrc"
alias za="code ~/.oh-my-zsh/custom/aliases.zsh"

# An alias for dvorak typists
alias aoeu='asdf'

# Some todo apps
alias t='reminders'
alias ta='reminders add'
alias td='reminders complete Reminders'
alias rsl='reminders show-lists'
alias tl='reminders show Reminders'

# `Now.md` convenience methods
export FOAM_HOME=~/workspace/foam
alias todos="ack '^.[^|\[]\[[^x]\]\s\w' ~/workspace/foam/now.md -C2"
alias prev-todos="ack '^.[^|\[]\[[^x]\]\s\w' prev.md -C2"
alias h2s="ack '^\#{2}\s' ~/workspace/foam/now.md -C1"
alias projects-w-context="ack  '(\+\+\w.*)'  ~/workspace/foam/now.md --output '$1'"
alias projects="ack -o '\+\+\w+' ~/workspace/foam/now.md | sort | uniq"


alias prev-projects="ack  '(\+\+\w.*)'  ~/workspace/foam/prev.md --output '$1'"
alias foam="cd ~/workspace/foam"
alias frogs="ack 'ğŸ¸' ~/workspace/foam/todo.md | sort"
alias nitty="ack 'ğŸ§¹' ~/workspace/foam/todo.md | sort"
alias cherry="ack 'ğŸ’' ~/workspace/foam/todo.md | sort"


# Github CLI

alias ttl="pmtl \n\n && gordtl \n\n && ghtl"

#####################   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—        Product Management Task List
#####################   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘
#####################   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
#####################   â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
#####################   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
#####################   â•šâ•â•     â•šâ•â•     â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•

function pmtl() {
  local headers="|Order | Status | Title | Project | Link|\n|---|---|---|---|---|"

  local result=$(gh p item-list 36 --limit 300 --format=json | jq -r '(.items | to_entries | map(select((.value.status == "In progress" or .value.status == "Backlog" or .value.status == "Waiting")))) | .[] | "| \(.key+1) | \(.value.status) | \(.value.title) | \(.value["project ğŸªš"]) | \((.value.content.repository | split("/")[-1]) + "/" + (.value.content.number|tostring)) |"')

  echo -e "### SL PM Tasks"
  echo -e "$headers"
  echo "$result"
  echo -e "$headers\n$result" | pbcopy
}


####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################

##################                   *******  ****     **** ********** **                  ** *******  ******
##################                  /**////**/**/**   **/**/////**/// /**                 /**/**////**/*////**
##################                  /**   /**/**//** ** /**    /**    /**                 /**/**   /**/*   /**
##################                  /******* /** //***  /**    /**    /**       *****     /**/******* /******
##################                  /**////  /**  //*   /**    /**    /**      /////      /**/**////  /*//// **
##################                  /**      /**   /    /**    /**    /**             **  /**/**      /*    /**
##################                  /**      /**        /**    /**    /********      //***** /**      /*******
##################                  //       //         //     //     ////////        /////  //       ///////

function pmtl-jpb() {
  local headers="|Order | Status | Title | Project | Link|\n|---|---|---|---|---|"

  local result=$(gh p item-list 36 --limit 300 --format=json | jq -r '(.items | to_entries | map(select((.value.status == "In progress" or .value.status == "Backlog" or .value.status == "Waiting") and (.value.assignees[]? | contains("jonathanpberger"))))) | .[] | "| \(.key+1) | \(.value.status) | \(.value.title) | \(.value["project ğŸªš"]) | \((.value.content.repository | split("/")[-1]) + "/" + (.value.content.number|tostring)) |"')

  echo -e "### SL PM Tasks for JPB"
  echo -e "$headers"
  echo "$result"
  echo -e "$headers\n$result" | pbcopy
}
# ######### this works
#
# function gordtl() {
#   local headers="|Title|Status|url|Assignees|\n|--|--|--|--|"
#   local result=$(gh p item-list 47 --limit 22 --format=json | jq -r '.items[] | "| \(.title) | \(.status) |\(.content.url) | \(.assignees // [] | if type == "array" then map(if type == "object" then .login else . end) else [] end | join(", ")) |"')

#   echo -e "### Gordian Tasks"
#   echo -e "$headers"
#   echo "$result"
#   echo -e "$headers\n$result" | pbcopy
# }
# #########


########################     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—        Gordian Task List
########################    â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘
########################    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
########################    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
########################    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
########################     â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•    â•šâ•â•   â•šâ•â•â•â•â•â•â•



function gordtl() {
  echo "Version 0.42"
  local headers="|Order|Status|Title|URL|Assignees|\n|--|--|--|--|--|"
  local result=$(gh p item-list 47 --format=json | jq -r '.items | to_entries[] | "| \(.key + 1) | \(.value.status) | \(.value.title) | \(.value.content.url) | \(.value.assignees // [] | if type == "array" then map(if type == "object" then .login else . end) else [] end | join(", ")) |"')

  local count=$(echo "$result" | wc -l | tr -d ' ')

  echo -e "### Gordian Tasks"
  echo -e "$headers\n$result"
  echo -e "$headers\n$result" | pbcopy
  echo -e "\n\n********* Gordian Tasks have been copied to the clipboard. There are $count tasks. :-) ###\n"
}


#################           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—          Github Task List
#################          â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘          Map this to whichever project is top priority.
#################          â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
#################          â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
#################          â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
#################           â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•



function ghtl() {
  local headers="|Order | Status | Title | url|"
  local separators="|$(echo "$headers" | sed 's/[^|]//g' | sed 's/|/---|/g' | sed 's/|$//')"

  local result=$(gh p item-list 46 --limit 300 --format=json | jq -r '(.items | to_entries | map(select((.value.status == "In progress" or .value.status == "Backlog" or .value.status == "Waiting") and (.value.assignees[]? | contains("jonathanpberger"))))) | .[] | "| \(.key+1) | \(.value.status) | \(.value.title) | \((.value.content.repository | split("/")[-1]) + "/" + (.value.content.number|tostring)) |"')

  echo -e "### README.lint Tasks"
  echo -e "$headers"
  echo -e "$separators"
  echo "$result"
  echo -e "$headers\n$result" | pbcopy
}


####################       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—
####################      â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
####################      â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
####################      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
####################      â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
####################       â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•



function ghi() {
  local user=$(gh api /user | jq -r '.login')
  local header="| Repository | Number | State | Title |url|"
  local separator="|------------|--------|-------|-----|--|"
  local results=$(gh search issues --assignee=@me --state=open --limit 333 --include-prs --json="repository,number,state,title,url" | jq -r '.[] | "| \(.repository.name) | \(.number) | \(.state) | \(.title) | \(.url) |"')
  local count=$(echo "$results" | wc -l | tr -d ' ')
  local title="### $count Open GitHub Issues for @$user"

  echo "$title"
  echo "$header"
  echo "$separator"
  echo "$results"

  echo -e "$title\n$header\n$separator\n$results" | pbcopy
  echo -e "\n$title have been copied to the clipboard. There are $count issues. :-) ###"
}

function ghi2() {
  gh search issues --assignee=@me --state=open
}



############    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— ANSI Shadow
############   â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•
############   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
############   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•
############   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
############    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•
############    TODO: extend lines in 30m increments, by duration
############    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•


########################################
# ChatGPT Pseudo-code
## Header Creation: Generates a header for the output, including the current date and week number (for Mondays).
#
## Table Headers: Prepares headers for the table that will display the calendar events.
#
## Fetching Calendar Data: Uses gcalcli to fetch today's agenda from Google Calendar. The --details length flag is used to include the duration of each event.
#
## Emoji Mapping: Defines a map of emojis for different times of the day. This is used to add a visual cue (emoji) to each event based on its start time.
#
## Processing Calendar Output: The main part of the script processes the output from gcalcli. It involves several steps:
#
## Removing ANSI color codes for plain text processing.
## Parsing each line to extract the time, duration, and description of events.
## Adding an emoji to the event if it doesn't start with one.
## Converting the event duration from hours and minutes to a total in minutes.
## Storing the processed information for each event.
## Expanding Events Longer than 30 Minutes: For events longer than 30 minutes, the script splits them into multiple 30-minute blocks. It uses a custom function add_pomodoro to increment the time by 30 minutes for each block.
#
## Handling Pomodoros and Event Conflicts: The script aims to remove pomodoro (ğŸ…) events that conflict with longer events. This step seems to need refinement based on the issues you're experiencing.
#
## Final Output Assembly: Constructs the final output table with the processed event data.
## ------------

## # Gday is a script to integrate my gCal with my daily notes. To help organize my time, the day should be broken into pomodoros wheverer I don't have existing appointments

## As JPB
## I want to connect my gCal to my daily notes
## Because I prefer to work in plaintext and markdown

## When I run gday
## Then all my gcal appointments should come in
## And any appointments longer than a pomodoro should be broken into 30m chunks
## And any appointments without an emoji should be assigned one based on their start time
## And their emoji should be duplicated for each chunk, ie the first Most Important Thing should start with ğŸ‘‘ and the second with ğŸ‘‘ğŸ‘‘, etc
## And any unscheduled time should be broken into pomodoros
## And any pomodoros that conflict with other events should be removed

## ## Pseudo-code
## - Create Table Headers and define clock Emoji Map
## - Fetch Calendar Data from Google Calendar
## - Remove ANSI color codes from Cal data
## - extract time, duration, and description of events from each line of Cal data
## - Add clock emoji to Cal data lines lacking emoji
## - Expand Events Longer than 30 Minutes into multiple lines, 30m each
## - Remove Pomodoro lines that conflict with other events
## - Render the final markdown table
#

########################################
########################################
########################################
########################################

function gday-neo() {

## 0.1 Create Table Headers

local date=$(date '+%m/%d - %A')
echo "Welcome to GDAY-NEO for $date"
processed_output+="# $date\n\n## ğŸª¢ Todo Today\n"
processed_output+="| Time    | Item                                             | -               |\n"
processed_output+="|---------|--------------------------------------------------|-----------------|\n"


## 0.2 Define clock Emoji Map
local -A emoji_map
emoji_map=( ["00"]="ğŸ•›" ["30"]="ğŸ•§" ["01"]="ğŸ•" ["31"]="ğŸ•œ" ["02"]="ğŸ•‘" ["32"]="ğŸ•"
            ["03"]="ğŸ•’" ["33"]="ğŸ•" ["04"]="ğŸ•“" ["34"]="ğŸ•Ÿ" ["05"]="ğŸ•”" ["35"]="ğŸ• "
            ["06"]="ğŸ••" ["36"]="ğŸ•¡" ["07"]="ğŸ•–" ["37"]="ğŸ•¢" ["08"]="ğŸ•—" ["38"]="ğŸ•£"
            ["09"]="ğŸ•˜" ["39"]="ğŸ•¤" ["10"]="ğŸ•™" ["40"]="ğŸ•¥" ["11"]="ğŸ•š" ["41"]="ğŸ•¦" )


## 1. Fetch & sanitize  Calendar Data from Google Calendar

local calendar_data=$(gcalcli --cal "JPB-DW" --cal "Pomo" --cal "JPB SL" --cal "JPB Private" agenda "1am today" "11pm today" --nocolor --no-military --details length --tsv)

# give a count of lines in calendar_data
calendar_data_lines=$(echo "$calendar_data" | wc -l)

# set a new var calendar_data_sifted to remove any pomodoro rows with a start time we've already seen in another row. Preserve the initial order of the rows


# Initial results
# 2024-04-29      00:00   2024-04-30      00:00   Home
# 2024-04-29      06:30   2024-04-29      08:45   get the kids up and out
# 2024-04-29      08:30   2024-04-29      09:00   ğŸ…
# 2024-04-29      08:45   2024-04-29      09:00   ğŸ¸ 15m of Monarch categorization
# 2024-04-29      09:00   2024-04-29      09:30   ğŸ…
# 2024-04-29      09:00   2024-04-29      09:30   ğŸª¢ Todo today
# 2024-04-29      09:15   2024-04-29      09:30   Check slack for open dYdX proposals which need to be voted on (search term: `in:#govstatements-votes dydx "new proposal"`)
# 2024-04-29      09:30   2024-04-29      10:00   ğŸ…
# 2024-04-29      09:30   2024-04-29      10:00   ğŸª¢ğŸ“† JPB IPM
# 2024-04-29      10:00   2024-04-29      10:30   ğŸ…
# 2024-04-29      10:00   2024-04-29      10:30   JPB and Alix Keller
# 2024-04-29      10:30   2024-04-29      11:00   ğŸ…
# 2024-04-29      10:30   2024-04-29      11:00   ğŸ¸ Eat 3 frogs
# 2024-04-29      11:00   2024-04-29      11:30   ğŸ…
# 2024-04-29      11:00   2024-04-29      11:20   Infra Standup
# 2024-04-29      11:30   2024-04-29      12:00   ğŸ…
# 2024-04-29      12:00   2024-04-29      12:30   ğŸ…
# 2024-04-29      12:00   2024-04-29      12:30   ğŸŒ Weekly SPoG review
# 2024-04-29      12:00   2024-04-29      13:00   Strangelove Family Mgmt Weekly
# 2024-04-29      12:00   2024-04-29      12:55   Art of Action Stand-up V6 (weekly)
# 2024-04-29      12:30   2024-04-29      13:00   ğŸ…
# 2024-04-29      13:00   2024-04-29      13:30   ğŸ…
# 2024-04-29      13:00   2024-04-29      13:30   ğŸœ Lunch
# 2024-04-29      13:00   2024-04-29      13:15   Yard Patrol ğŸŒ± Touch grass
# 2024-04-29      13:30   2024-04-29      14:00   ğŸ…
# 2024-04-29      13:30   2024-04-29      14:00   ğŸ§¹ Knock out ~3 nitty-gritties
# 2024-04-29      14:00   2024-04-29      14:30   ğŸ…
# 2024-04-29      14:00   2024-04-29      15:00   ğŸ¦Š Ship README.lint PR (or owe ğŸº to @Ollie)
# 2024-04-29      14:00   2024-04-29      16:30   ğŸ‘‘ A-priority only focus time
# 2024-04-29      14:30   2024-04-29      15:00   ğŸ…
# 2024-04-29      15:00   2024-04-29      15:30   ğŸ…
# 2024-04-29      15:30   2024-04-29      16:00   ğŸ…
# 2024-04-29      16:00   2024-04-29      16:30   ğŸ…
# 2024-04-29      16:30   2024-04-29      17:00   ğŸ…
# 2024-04-29      17:00   2024-04-29      17:30   ğŸ…
# 2024-04-29      17:00   2024-04-29      17:15   ğŸ’ What did you ğŸš¢ today?


# Desired results
# 2024-04-29      00:00   2024-04-30      00:00   Home
# 2024-04-29      06:30   2024-04-29      08:45   get the kids up and out
# 2024-04-29      08:45   2024-04-29      09:00   ğŸ¸ 15m of Monarch categorization
# 2024-04-29      09:00   2024-04-29      09:30   ğŸª¢ Todo today
# 2024-04-29      09:15   2024-04-29      09:30   Check slack for open dYdX proposals which need to be voted on (search term: `in:#govstatements-votes dydx "new proposal"`)
# 2024-04-29      09:30   2024-04-29      10:00   ğŸª¢ğŸ“† JPB IPM
# 2024-04-29      10:00   2024-04-29      10:30   JPB and Alix Keller
# 2024-04-29      10:30   2024-04-29      11:00   ğŸ¸ Eat 3 frogs
# 2024-04-29      11:00   2024-04-29      11:20   Infra Standup
# 2024-04-29      11:00   2024-04-29      11:30   ğŸ…
# 2024-04-29      11:30   2024-04-29      12:00   ğŸ…
# 2024-04-29      12:00   2024-04-29      12:30   ğŸŒ Weekly SPoG review
# 2024-04-29      12:00   2024-04-29      13:00   Strangelove Family Mgmt Weekly
# 2024-04-29      12:00   2024-04-29      12:55   Art of Action Stand-up V6 (weekly)
# 2024-04-29      12:30   2024-04-29      13:00   ğŸ…
# 2024-04-29      13:00   2024-04-29      13:30   ğŸœ Lunch
# 2024-04-29      13:00   2024-04-29      13:15   Yard Patrol ğŸŒ± Touch grass
# 2024-04-29      13:30   2024-04-29      14:00   ğŸ§¹ Knock out ~3 nitty-gritties
# 2024-04-29      14:00   2024-04-29      14:30   ğŸ…
# 2024-04-29      14:00   2024-04-29      15:00   ğŸ¦Š Ship README.lint PR (or owe ğŸº to @Ollie)
# 2024-04-29      14:00   2024-04-29      16:30   ğŸ‘‘ A-priority only focus time
# 2024-04-29      15:00   2024-04-29      15:30   ğŸ…
# 2024-04-29      15:30   2024-04-29      16:00   ğŸ…
# 2024-04-29      16:00   2024-04-29      16:30   ğŸ…
# 2024-04-29      16:30   2024-04-29      17:00   ğŸ…
# 2024-04-29      17:00   2024-04-29      17:30   ğŸ…
# 2024-04-29      17:00   2024-04-29      17:15   ğŸ’ What did you ğŸš¢ today?








  ## 1a. Fetch
  ## 1b. Remove ANSI color codes from Cal data

## 3. extract time, duration, and description of events from each line of Cal data

## 3a. create list of h2s



## 4. Add clock emoji to Cal data lines lacking emoji
## 5. Expand Events Longer than 30 Minutes into multiple lines, 30m each
## 6. Remove Pomodoro lines that conflict with other events
## 7. Render the final markdown table





}


########################################
########################################
########################################
########################################



# Increment time function
function increment_time() {
    local time=$1
    local hour=$(echo $time | cut -d ':' -f 1)
    local minute=$(echo $time | cut -d ':' -f 2 | sed 's/[apm]*//g')
    local period=$(echo $time | grep -o '[apm]*')
    local new_minute=$((minute + 30))

    if [[ $new_minute -ge 60 ]]; then
        new_minute=$((new_minute % 60))
        hour=$((hour % 12 + 1))
    fi

    if [[ $hour -eq 12 && $period == "am" ]]; then
        period="pm"
    elif [[ $hour -eq 12 && $period == "pm" ]]; then
        period="am"
    fi

    printf "%d:%02d%s" $hour $new_minute $period
}

# Transform gcalcli output to desired markdown format
function transform_gcal_output() {
    local raw_output=$1
    echo "***************** Debug: Starting transform_gcal_output \n\n\n\n\n\n"

    local processed_output=""
    local current_time=""
    local current_event=""
    local current_length=""
    local -A emoji_map
    emoji_map=( ["00"]="ğŸ•›" ["30"]="ğŸ•§" ["01"]="ğŸ•" ["31"]="ğŸ•œ" ["02"]="ğŸ•‘" ["32"]="ğŸ•"
                ["03"]="ğŸ•’" ["33"]="ğŸ•" ["04"]="ğŸ•“" ["34"]="ğŸ•Ÿ" ["05"]="ğŸ•”" ["35"]="ğŸ• "
                ["06"]="ğŸ••" ["36"]="ğŸ•¡" ["07"]="ğŸ•–" ["37"]="ğŸ•¢" ["08"]="ğŸ•—" ["38"]="ğŸ•£"
                ["09"]="ğŸ•˜" ["39"]="ğŸ•¤" ["10"]="ğŸ•™" ["40"]="ğŸ•¥" ["11"]="ğŸ•š" ["41"]="ğŸ•¦" )

    # Header
    local date=$(date '+%m/%d - %A')
    processed_output+="# $date\n\n## ğŸª¢ Todo Today\n"
    processed_output+="| Time    | Item                                             | -               |\n"
    processed_output+="|---------|--------------------------------------------------|-----------------|\n"

    local -a lines
    lines=("${(@f)raw_output}")
    echo "########### lines starting here"
    echo $lines
    echo "########### end of lines var"
    local is_event_line=false

    for line in $lines; do
        echo "$line"
        if [[ $line =~ ^[[:space:]]*[0-9]{1,2}:[0-9]{2}[apm]{2} ]]; then
            current_time=$(echo $line | awk '{print $1}')
            current_event=$(echo $line | awk '{$1=""; print substr($0,2)}' | xargs)
            current_length=""
            is_event_line=true
        elif [[ $line =~ Length: ]] && $is_event_line; then
            current_length=$(echo $line | awk '{print $2}')
            local duration_minutes=$(echo $current_length | awk -F: '{print $1 * 60 + $2}')
            if [[ $duration_minutes -gt 30 ]]; then
                local blocks=$((duration_minutes / 30))
                for ((i=1; i<=blocks; i++)); do
                    local emoji_time=$(echo $current_time | cut -d ':' -f 2 | cut -d [apm]* -f 1)
                    local emoji=${emoji_map[$emoji_time]}
                    local prefix=$(printf "%.0s${emoji}" $(seq 1 $i))
                    processed_output+="| $current_time | $prefix $current_event | Length: $current_length |\n"
                    current_time=$(increment_time $current_time)
                done
            else
                processed_output+="| $current_time | $current_event | |\n"
            fi
            is_event_line=false
        fi
    done

    # Footer
    processed_output+="\n- ğŸ‘‘ Most Important Thing Today:\n- 1st ğŸ¸ I'll eat:\n- 2nd ğŸ¸ I'll eat:\n- 3rd ğŸ¸ I'll eat:\n"

    echo -e "$processed_output"
}

# Main gday function
function gday-factored() {
    # Display header
    echo "    ğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒ"
    echo "    ğŸŒğŸŒğŸŒ   gday Version 1.64.1    ğŸŒğŸŒğŸŒ"
    echo "    ğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒ \n\n"

    # Fetch calendar data
    echo "################### Debug: Fetching calendar data \n"
    local raw_output=$(gcalcli --cal "JPB-DW" --cal "Pomo" --cal "JPB SL" --cal "JPB Private" agenda "1am today" "11pm today" --nocolor --no-military --details length --tsv)

    # Process and transform the output
    transform_gcal_output "$raw_output"


}

########################################
########################################
########################################
########################################


# path/filename: ~/scripts/todo_project_count.sh
# This script generates a markdown table with a list of unique projects and their counts from the todo.md file.
# Function to extract projects and count occurrences
generate_project_table() {
  local todo_file=$1
  echo "| Project | Count |"
  echo "|---------|-------|"
  grep -o "++[a-zA-Z0-9_]*" "$todo_file" | sort | uniq -c | while read -r count project; do
    # Clean project name and format as markdown table row
    project=${project//++/}
    echo "| $project | $count |"
  done
}

# Call the function with the path to the todo.md file
# generate_project_table "/path/to/todo.md"


########################################
########################################
########################################
########################################
############# GDAY MIKE
########################################
########################################
########################################
########################################


# gday-mike Version 1.38.0

function gday-mike() {
  echo "    ğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒ"
  echo "    ğŸŒğŸŒğŸŒ   gday Version 1.38.0 Mike    ğŸŒğŸŒğŸŒ"
  echo "    ğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒ \n\n"

  local calendar_data=$(gcalcli --cal "JPB-DW" --cal "Pomo" --cal "JPB SL" --cal "JPB Private" agenda "1am today" "11pm today" --nocolor --no-military --details length --tsv)

  echo "Raw gcalcli results:"
  echo "$calendar_data"
  local line_count=$(echo "$calendar_data" | wc -l | xargs)
  echo "Line count: $line_count"
  echo "-----------------"

  if [[ -z "$calendar_data" || "$line_count" -eq 0 ]]; then
    echo "No calendar data found or gcalcli failed."
    return
  fi

  typeset -A all_items
  while IFS=$'\t' read -r start_date start_time end_date end_time item; do
    # Convert to 12-hour format and remove leading zero
    start_time=$(date -d "$start_date $start_time" +"%I:%M %p" 2>/dev/null || date -jf "%Y-%m-%d %H:%M" "$start_date $start_time" +"%I:%M %p" 2>/dev/null | sed 's/^0//')
    # Use a unique key combining time and item to ensure uniqueness
    all_items["$start_time,$item"]=1
  done <<< "$(echo "$calendar_data")"

  # Sort and print the items
  echo "## ğŸª¢ Todo Today"
  echo "| Time    | Item |"
  echo "|---------|------|"
  for key in ${(ok)all_items}; do
    local time=${key%%,*}
    local item=${key#*,}
    # Directly print without quotes
    printf "| %s | %s |\n" "$time" "$item"
  done

  echo "\n- ğŸ‘‘ Most Important Thing Today:"
  echo "- 1st ğŸ¸ I'll eat:"
  echo "- 2nd ğŸ¸ I'll eat:"
  echo "- 3rd ğŸ¸ I'll eat:\n"
}

# Note: Adjust the `date` command as needed for compatibility with macOS or Linux.






########################################
########################################
########################################
########################################

extract_h2s() {
  awk '
    BEGIN {
      print "## Later Today..."
      print "```"
    }
    function normalize(str) {
      gsub(/[^a-zA-Z0-9 ]/, "", str);
      return str;
    }
    /^\| [0-9]/ {
      sub(/^\|[^|]+\| /, "## ");
      gsub(/ \|$/, "");
      norm = normalize($0);
      if (!seen[norm]++) {
        print $0
      }
    }
    END { print "```" }
  '
}


########################################
########################################
########################################
########################################

function gday-old() {
  echo "    ğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒ"
  echo "    ğŸŒğŸŒğŸŒ   gday Version 1.30.1    ğŸŒğŸŒğŸŒ"
  echo "    ğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒğŸŒ \n\n"
  # TODO: Cull pomodoros for times which already have appointments
  # TODO: When splitting long events into multiple pomodoros, duplicate the emoji for each pomodoro
  # TODO: Add tests. Maybe <https://github.com/shellspec/shellspec>?
  # TODO: Parse pseudo-code into Features List / Release Notes


  ##### Setup
  declare -A emoji_map=(
    [800]="ğŸ•—" [830]="ğŸ•£" [900]="ğŸ•˜" [930]="ğŸ•¤"
    [1000]="ğŸ•™" [1030]="ğŸ•¥" [1100]="ğŸ•š" [1130]="ğŸ•¦"
    [1200]="ğŸ•›" [1230]="ğŸ•§" [100]="ğŸ•" [130]="ğŸ•œ"
    [200]="ğŸ•‘" [230]="ğŸ•" [300]="ğŸ•’" [330]="ğŸ•"
    [400]="ğŸ•“" [430]="ğŸ•Ÿ" [500]="ğŸ•”" [530]="ğŸ• "
    [600]="ğŸ••" [630]="ğŸ•¡" [700]="ğŸ•–" [730]="ğŸ•¢"
  )

  local title="## ğŸª¢ Todo Today"
  local table_header="| Time    | Item |"
  local table_separator="|---------|------|"
  local kicker="\n- ğŸ‘‘ Most Important Thing Today:\n- 1st ğŸ¸ I'll eat:\n- 2nd ğŸ¸ I'll eat:\n- 3rd ğŸ¸ I'll eat:\n\n"

  ###### Day of week should include ğŸ“… and weeknum on Mondays
  local day_of_week=$(date '+%A')
  local h1="# $(date '+%m/%d') - ${day_of_week}"

  if [[ $day_of_week == "Monday" ]]; then
    h1+=" - ğŸ“† Week $(date '+%V')"
  fi

  local calendar_data=$(gcalcli --cal "JPB-DW" --cal "Pomo" --cal "JPB SL" --cal "JPB Private" agenda "1am today" "11pm today" --nocolor --no-military --details length)
  local calendar_data_no_color=$(echo "$calendar_data" | sed 's/\x1b\[[0-9;]*m//g')

  ###### convert pipe characters to an em-dash (bc escaping pipes is hard)
  calendar_data_no_color=$(echo "$calendar_data_no_color" | sed 's/|/â€”/g')

  local body=""
  local lines=()
  local time_count=()

##### Process the calendar data
while IFS= read -r line; do
  line=$(echo "$line" | sed 's/^[ \t]*//') # trim whitespace

  # Function to add a pomodoro (30 minutes) to a given time
  add_pomodoro() {
    local time=$1
    local new_time=$(date -j -v+30M -f "%I:%M%p" "$time" +"%I:%M%p")
    echo $new_time | sed 's/^0//' | tr '[:upper:]' '[:lower:]'
  }

  if [[ $line =~ ^[0-9]{1,2}:[0-9]{2}[apm]{2} ]]; then # if line starts with time
    local time=$(echo "$line" | awk '{print $1}') # extract vars
    local item=$(echo "$line" | awk '{$1=""; print substr($0,2)}')

    # Split >30m events into multiple lines
    IFS= read -r next_line
    local duration_raw=$(echo "$next_line" | awk '/Length:/ {print $2}')
    local hours=$(echo "$duration_raw" | cut -d ':' -f 1)
    local minutes=$(echo "$duration_raw" | cut -d ':' -f 2)
    local total_minutes=$((hours * 60 + minutes))
    local blocks=$((total_minutes / 30))

    for ((i=0; i<blocks; i++)); do
      lines+=("$time|$item")
      time=$(add_pomodoro "$time")
    done
  fi
done <<< "$calendar_data_no_color"

##### Add emoji to items lacking emoji and construct the final table
for line in "${lines[@]}"; do
  IFS='|' read -r time item <<< "$line"
  local time_number=$(echo "$time" | tr -d '[:alpha:]' | tr -d ':')

  if ! [[ $item =~ ^[^[:alnum:]] ]]; then # if item lacks emoji
    local emoji=${emoji_map[$time_number]} # then add emoji
    item="${emoji} $item"
  fi

  body+="| ${time} | ${item} |"$'\n'
done

echo -e "${h1}\n\n${title}\n${table_header}\n${table_separator}\n${body}\n\n${kicker}"

}

############################    ___|  ____| __ __|       _ \    _ \    _ \       |  ____|   ___| __ __|     _ _| __ __|  ____|   \  |   ___|  ###################
############################   |      __|      |        |   |  |   |  |   |      |  __|    |        |         |     |    __|    |\/ | \___ \  ################### Get project items, done w/ copilot.
############################   |   |  |        |        ___/   __ <   |   |  \   |  |      |        |         |     |    |      |   |       | ################### THIS WORKS
############################  \____| _____|   _|       _|     _| \_\ \___/  \___/  _____| \____|   _|       ___|   _|   _____| _|  _| _____/  ###################

function get_project_items {
  # Version 1.1.0
  assignee_filter=${1:-""}
  shift
  project_numbers=("$@")

  current_date=$(date +"%m-%d-%Y")
  limit=333
  echo "~~~~~~~~~~~~~~~~~~ limit: $limit ~~~~~~~~~~~~~~~~~~\n\n"

  echo -e "\n\n### ğŸ‘‘ Epics (as of $current_date)\n| Project | Title | Status | Story Type | Assignees | URL |\n|---------|-------|--------|------------|-----------|-----|"
  for project in "${project_numbers[@]}"; do
    gh p item-list $project --format json --limit $limit -q ".items[] | select((.status? // \"\") | test(\"In progress|Backlog|Waiting/Review\")) | select(.assignees==\"$assignee_filter\" or \"$assignee_filter\"==\"\") | select(if .[\"story Type\"]? then (.[\"story Type\"] // \"\") | test(\"Epic\") else false end) | \"| $project | \(.title) | \(.status) | \(.[\"story Type\"]) | \(.assignees) | \(.content.url | sub(\"https://github.com/strangelove-ventures/\"; \"\")) |\""
  done

  echo -e "\n\n### â­ï¸ğŸâš™ï¸ğŸ Stories (as of $current_date, excluding Icebox and Done)\n| Project | Title | Status | Story Type | Assignees | URL |\n|---------|-------|--------|------------|-----------|-----|"
  for project in "${project_numbers[@]}"; do
    gh p item-list $project --format json --limit $limit -q ".items[] | select((.status? // \"\") | test(\"In progress|Backlog|Waiting/Review\")) | select(.assignees==\"$assignee_filter\" or \"$assignee_filter\"==\"\") | select(if .[\"story Type\"]? then ((.[\"story Type\"] // \"\") | test(\"Epic\")) | not else true end) | \"| $project | \(.title) | \(.status) | \(.[\"story Type\"]) | \(.assignees) | \(.content.url | sub(\"https://github.com/strangelove-ventures/\"; \"\")) |\""
  done
}

# Usage:
# get_project_items "assignee_name" 36 49 48 30 39
# get_project_items "" 36 49 48 30 39



######################   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—        # alltl function v0.1
######################  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘        # Retrieves a combined list of all GitHub issues assigned to me and their project status.
######################  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘        # Depends on GitHub CLI (`gh`) and `jq` for processing JSON.
######################  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
######################  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
######################  â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•   â•šâ•â•â•â•â•â•â•

function alltl() {
  # Get list of issues assigned to me
  local issues=$(gh issue list --assignee @me --json number,title,repository --jq '.[] | {number, title, repo: .repository.nameWithOwner}')

  # Get list of projects I'm a member of
  local projects=$(gh api graphql -f query='
    {
      viewer {
        projectsV2(first: 10) {
          nodes {
            name
            items(first: 100) {
              nodes {
                content {
                  ... on Issue {
                    number
                  }
                }
                fieldValues(first: 10) {
                  nodes {
                    projectField {
                      name
                    }
                    value
                  }
                }
              }
            }
          }
        }
      }
    }' --jq '.data.viewer.projectsV2.nodes[] | {project: .name, items: [.items.nodes[] | {number: .content.number, status: (.fieldValues.nodes[] | select(.projectField.name == "Status") | .value)]}}')

  # Synthesize table with combined data
  local header="| Title | Repo Name / Issue Number | Assigned Project | Status |"
  local separator="|-------|-------------------------|------------------|--------|"
  echo "$header"
  echo "$separator"

  for issue in $(echo "$issues" | jq -c '.'); do
    local issue_number=$(echo "$issue" | jq -r '.number')
    local issue_title=$(echo "$issue" | jq -r '.title')
    local issue_repo=$(echo "$issue" | jq -r '.repo')
    local project_name="none"
    local status="none"

    # Check projects for this issue
    for project in $(echo "$projects" | jq -c '.'); do
      local p_name=$(echo "$project" | jq -r '.project')
      local p_issue=$(echo "$project" | jq --arg number "$issue_number" '.items[] | select(.number == ($number | tonumber))')
      if [ "$p_issue" != "" ]; then
        if [ "$project_name" == "none" ]; then
          project_name=$p_name
          status=$(echo "$p_issue" | jq -r '.status')
        else
          project_name="many"
          status="many"
          break
        fi
      fi
    done

    echo "| $issue_title | $issue_repo / $issue_number | $project_name | $status |"
  done | column -t -s '|'

  echo "Table has been synthesized."
}

function collect_field_names() {
  local version="v0.4"

  # Emit the version information
  echo "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ collect_field_names [$version] â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"

  # Retrieve and map the project names to their numbers
  local project_info=$(gh project list --owner strangelove-ventures --format json ) | jq -r '[.[] | {number, name}]'

  # Define the list of project numbers
  local project_numbers=(46 49 39 36 34 30 24 18)

  # Iterate over the project numbers to retrieve and print field names
  for project_number in $project_numbers; do
    # Extract the project name using the project number
    local project_name=$(echo "$project_info" | jq -r --argjson number $project_number '.[] | select(.number == $number) | .name')

    # Print the project name
    echo "Project $project_number ($project_name) fields:"

    # Retrieve and print the field names for the project
    gh project field-list $project_number --owner strangelove-ventures --format json |
      jq -r '[.fields[].name] | join(", ")'
    echo # Print a newline for better readability
  done
}

##################################################   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— Map all issues to projects.
##################################################   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
##################################################   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
##################################################   â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘
##################################################   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
##################################################   â•šâ•â•     â•šâ•â•     â•šâ•â•

function ppi() {
  echo "Version 0.6.1"

  echo "Fetching current user..."
  local user=$(gh api /user | jq -r '.login')

  echo "Fetching Gordian tasks..."
  local gordianTasks=$(gh p item-list 47 --format=json | jq -r '
    .items | map({
      status: .status,
      title: .title,
      url: .content.url,
      assignees: (.assignees // [] | join(", "))
    })'
  )

  echo "Fetching PM tasks from another project..."
  local pmTasks=$(gh p item-list 36 --limit 300 --format=json | jq -r '
    .items | map(select(.content.url != null)) | map({
      status: .status,
      title: .title,
      project: .["project ğŸªš"],
      url: .content.url,
      projectStatuses: [{project: .project, status: .status}]
    })'
  )

  echo "Fetching GitHub issues..."
  local gitHubIssues=$(gh search issues --assignee=@me --state=open --limit=333 --include-prs --json="repository,number,state,title,url" | jq -r '.[] | {repository: .repository.name, number: .number, state: .state, title: .title, url: .url}')

  echo "Combining tasks and issues..."
  local combinedResults=$(jq -n '
    input as $gordianTasks | input as $pmTasks | input as $gitHubIssues |
    ($gordianTasks + $pmTasks + $gitHubIssues) | group_by(.url) | map({
      title: .[0].title,
      status: .[0].status,
      state: (.[0].state // ""),
      assignees: .[0].assignees,
      repository: (.[0].repository // ""),
      number: (.[0].number // ""),
      url: .[0].url,
      projectStatuses: (reduce .[] as $item ([]; . + ($item.projectStatuses // [])))
    })' <(echo "$gordianTasks") <(echo "$pmTasks") <(echo "$gitHubIssues"))

  local combinedTable=$(echo "$combinedResults" | jq -r '.[] | select(.url != null) | "| \(.title) | \(.status) // (if .projectStatuses then (.projectStatuses | map(.status) | join(", ")) else "N/A" end) | \(.assignees) | \(.repository) | \(.number) | \(.state) | \(.url) |"')

  local count=$(echo "$combinedResults" | jq -r 'length')
  local title="### Combined Gordian and SL PM Tasks with GitHub Issues for @$user"

  local tableHeader="|URL|Title|Status|Assignees|Repository|Issue Number|Issue State|"
  local separator="|---|-----|------|---------|----------|------------|-----------|"

  echo -e "$title\n$tableHeader\n$separator\n$combinedTable"

  echo -e "$title\n$tableHeader\n$separator\n$combinedTable" | pbcopy
  echo -e "\n$title have been copied to the clipboard. There are $count combined tasks and issues. :-) ###"
}

##  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
##  â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
##  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
##  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘
##  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
##  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â•     â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•


echo "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ Finished Loading aliases!\n\n"

